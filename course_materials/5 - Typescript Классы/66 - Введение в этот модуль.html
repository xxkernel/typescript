<p>Как и с другими возможностями JS, TypeScript отлично работает с классами и предоставляет удобные инструменты для этого. Для прохождения этого модуля:</p><ol><li><p><strong>Необходимо</strong> знать,&nbsp;что такое классы (ES6) и понимать как они работают. <br>Если вдруг подзабыли, то освежить знания или даже быстро их изучить можно вот тут: <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes" rel="noopener noreferrer" target="_blank">ссылка</a> (и еще 6 последовательных ссылок дальше по топику)<br></p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-12-11_14-25-09-fe301ef9edba248df62d9fe041d2c1bb.png"></figure></li><li><p><strong>Желательно</strong> понимать основы ООП. Я не говорю,&nbsp;что нужно от корки до корки прочитать книгу на 1000 страниц, но базовые понятия желательно знать. <br><br>Простым языком почитать можно тут: <a href="https://blog.skillfactory.ru/glossary/oop-obektno-orientirovannoe-programmirovanie/" rel="noopener noreferrer" target="_blank">ссылка</a> (ru ссылка, может быть <strong>заблокирована</strong>. Размещу копию текста ниже для ознакомления)<br>Чуть сложнее будет на вики: <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" rel="noopener noreferrer" target="_blank">ссылка</a><br>Коротко, сложновато, не до конца раскрыто, но с некоторыми идеями соглашусь: <a href="https://habr.com/ru/company/otus/blog/525336/" rel="noopener noreferrer" target="_blank">ссылка</a></p></li></ol><p>Конечно, я буду стараться раскрыть эти моменты и в уроках, но восприниматься будет проще, если вы это уже читали. </p><p>Если говорить про классы в целом, то они могут использоваться много где (библиотеки, фреймворки), но все будет зависеть от конкретного проекта. И бывает так,&nbsp;что вы с ними и не столкнетесь. Так как сейчас тренд больше на функциональщину (React Hooks как яркий пример) И стоит сказать, что на бекенде классов сейчас побольше :) А TypeScript проник и туда.</p><p>Так что знать эту тему <strong>нужно</strong>, а с базовыми знаниями она зайдет в голову довольно быстро.</p><h4><strong>Копия текста из заблокированной статьи</strong></h4><p>Оригинал размещен тут: <a href="https://blog.skillfactory.ru/glossary/oop-obektno-orientirovannoe-programmirovanie/" rel="noopener noreferrer" target="_blank">ссылка</a></p><p>Объектно-ориентированное программирование (ООП) — это подход, при котором программа рассматривается как набор объектов, взаимодействующих друг с другом. У каждого есть свойства и поведение. ООП ускоряет написание кода и делает его более читаемым.</p><p>Идеология объектно-ориентированного программирования (ООП) разрабатывалась, чтобы связать поведение определенного объекта с его классом. Людям проще воспринимать окружающий мир как объекты, которые поддаются определенной классификации (например, разделение на живую и неживую природу).</p><h4>Зачем нужно ООП</h4><p>До ООП в разработке использовался другой подход — процедурный. Программа представляется в нем как набор процедур и функций — подпрограмм, которые выполняют определенный блок кода с нужными входящими данными. Процедурное программирование хорошо подходит для легких программ без сложной структуры. Но если блоки кода большие, а функций сотни, придется редактировать каждую из них, продумывать новую логику. В результате может образоваться много плохо читаемого, перемешанного кода — «спагетти-кода» или «лапши».</p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-12-11_14-25-09-ad04dcf4cb7faf69b38ce8ac46015d5b.png"></figure><blockquote><p>Пример «спагетти-кода»</p></blockquote><p>В отличие от процедурного, объектно-ориентированное программирование позволяет вносить изменения один раз — в объект. Именно он — ключевой элемент программы. Все операции представляются как взаимодействие между объектами. При этом код более читаемый и понятный, программа проще масштабируется.</p><p>Объектно-ориентированное программирование используется, чтобы:</p><ul><li><p>структурировать информацию и не допускать путаницы;</p></li><li><p>точно определять взаимодействие одних элементов с другими;</p></li><li><p>повышать управляемость программы;</p></li><li><p>быстрее масштабировать код под различные задачи;</p></li><li><p>лучше понимать написанное;</p></li><li><p>эффективнее поддерживать готовые программы;</p></li><li><p>внедрять изменения без необходимости переписывать весь код.</p></li></ul><p>Возможности ООП поддерживает большинство популярных языков программирования, включая JavaScript, PHP, Python и другие.</p><h4>Структура ООП</h4><h4>Объекты и классы</h4><p>Чтобы сделать код проще, программу разбивают на независимые блоки — объекты. В реальной жизни это может быть стол, чашка, человек, книга, здание и многое другое. В программировании объекты — это структуры данных: пользователь, кнопка, сообщение. У них, как и у реальных предметов, могут быть свойства: цвет, содержание или имя пользователя. А чтобы объединить между собой объекты с похожими свойствами, существуют классы.</p><p>Класс — это «шаблон» для объекта, который описывает его свойства. Несколько похожих между собой объектов, например профили разных пользователей, будут иметь одинаковую структуру, а значит, принадлежать к одному классу. Каждый объект — это экземпляр какого-нибудь класса.</p><p>Понять, что такое ООП, поможет аналогия.</p><ul><li><p>Понятие «программист» — это класс.</p></li><li><p>Конкретный разработчик по имени Иван — это объект, принадлежащий к классу «программист» (экземпляр класса).</p></li><li><p>Зарплата, рабочие обязанности, изученные технологии и должность в компании — это свойства, которые есть у всех объектов класса «программист», в том числе у Ивана. У разных объектов свойства различаются: зарплата и обязанности Ивана будут отличаться от таковых у другого разработчика Миши.</p></li></ul><h4>Атрибуты и методы</h4><p>Объект — это набор переменных и функций, как в традиционном функциональном программировании. Переменные и функции и есть его свойства.</p><ul><li><p>Атрибуты — это переменные, конкретные характеристики объекта, такие как цвет поля или имя пользователя.</p></li><li><p>Методы — это функции, которые описаны внутри объекта или класса. Они относятся к определенному объекту и позволяют взаимодействовать с ними или другими частями кода.</p></li></ul><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-12-11_14-25-09-615cba2fb9db26d2134c8b90c8d9dda0.png"></figure><h4>Принципы ООП</h4><p>Объектно-ориентированное программирование определяют через четыре принципа, по которым можно понять основы работы. Иногда количество сокращают до трех — опускают понятие абстракции.</p><h4><strong>Абстракция</strong></h4><p>Абстрагирование — это способ выделить набор наиболее важных атрибутов и методов и исключить незначимые. Соответственно, абстракция — это использование всех таких характеристик для описания объекта. Важно представить объект минимальным набором полей и методов без ущерба для решаемой задачи.</p><p>Пример: объекту класса «программист» вряд ли понадобятся свойства «умение готовить еду» или «любимый цвет». Они не влияют на его особенности как программиста. А вот «основной язык программирования» и «рабочие навыки» — важные свойства, без которых программиста не опишешь.</p><p>Набор атрибутов и методов, доступный извне, работает как интерфейс для доступа к объекту. Через них к нему могут обращаться другие структуры данных, причем им не обязательно знать, как именно объект устроен внутри.</p><h4><strong>Инкапсуляция</strong></h4><p>Каждый объект — независимая структура. Все, что ему нужно для работы, уже есть у него внутри. Если он пользуется какой-то переменной, она будет описана в теле объекта, а не снаружи в коде. Это делает объекты более гибкими. Даже если внешний код перепишут, логика работы не изменится.</p><p>Инкапсуляция помогает с легкостью управлять кодом. Выше мы сказали, что для обращения к объекту не нужно понимать, как работают его методы. Начальнику разработчика Ивана не обязательно знать, как именно он программирует: главное — чтобы выполнялись поставленные задачи.</p><p>Внутреннее устройство одного объекта закрыто от других: извне «видны» только значения атрибутов и результаты выполнения методов.</p><h4><strong>Наследование</strong></h4><p>Можно создавать классы и объекты, которые похожи друг на друга, но немного отличаются — имеют дополнительные атрибуты и методы. Более общее понятие в таком случае становится «родителем», а более специфичное и подробное — «наследником».</p><p>Упомянутый программист Иван — это человек. Но «человек» — более общее определение, которое не описывает свойства, важные именно для программиста. Можно сказать, что класс «программист» унаследован от класса «человек»: программист тоже является человеком, но у него есть дополнительные свойства.</p><p>В таком случае разработчик Иван будет и человеком, и программистом одновременно. У него будут наборы свойств от обоих классов.</p><p>У одного «родителя» может быть несколько дочерних структур. Например, от «человека» можно наследовать не только «программиста», но и «директора».</p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2022-12-11_14-25-09-decdcc5d77b78b86e5d0944d07229904.png"></figure><p>Наследование позволяет реализовывать сложные схемы с четкой иерархией «от общего к частному». Это облегчает понимание и масштабирование кода. Не нужно много раз переписывать в разных объектах одни и те же свойства. Достаточно унаследовать эти объекты от одного «родителя», и «родительские» свойства применятся автоматически.</p><h4><strong>Полиморфизм</strong></h4><p>Одинаковые методы разных объектов могут выполнять задачи разными способами. Например, у «человека» есть метод «работать». У «программиста» реализация этого метода будет означать написание кода, а у «директора» — рассмотрение управленческих вопросов. Но глобально и то, и другое будет работой.</p><p>Тут важны единый подход и договоренности между специалистами. Если метод называется delete, то он должен что-то удалять. Как именно — зависит от объекта, но заниматься такой метод должен именно удалением. Более того: если оговорено, что «удаляющий» метод называется delete, то не нужно для какого-то объекта называть его remove или иначе. Это вносит путаницу в код.</p><h4><strong>Преимущества ООП</strong></h4><h4>Модульность</h4><p>Объектно-ориентированный подход позволяет сделать код более структурированным, в нем легко разобраться стороннему человеку. Благодаря инкапсуляции объектов уменьшается количество ошибок и ускоряется разработка с участием большого количества программистов, потому что каждый может работать независимо друг от друга.</p><h4>Гибкость</h4><p>ООП-код легко развивать, дополнять и изменять. Это обеспечивает независимая модульная структура. Взаимодействие с объектами, а не логикой упрощает понимание кода. Для модификации не нужно погружаться в то, как построено ПО. Благодаря полиморфизму можно быстро адаптировать код под требования задачи, не описывая новые объекты и функции.</p><h4>Экономия времени</h4><p>Благодаря абстракции, полиморфизму и наследованию можно не писать один и тот же код много раз. Это ускоряет разработку нового ПО. Интерфейсы и классы в ООП могут легко преобразовываться в подобие библиотек, которые можно использовать заново в новых проектах. Также ООП экономит время при поддержке и доработке приложения.</p><h4>Безопасность</h4><p>Программу сложно сломать, так как инкапсулированный код недоступен извне.</p><h4><strong>Недостатки ООП</strong></h4><h4>Сложный старт</h4><p>Чтобы пользоваться ООП, нужно сначала изучить теорию и освоить процедурный подход, поэтому порог входа высокий.</p><h4>Снижение производительности</h4><p>Объектно-ориентированный подход немного снижает производительность кода в целом. Программы работают несколько медленнее из-за особенностей доступа к данным и большого количества сущностей.</p><h4>Большой размер программы</h4><p>Код, написанный с использованием ООП, обычно длиннее и занимает больше места на диске, чем «процедурный». Это происходит, потому что в такой программе хранится больше конструкций, чем в обычном процедурном скрипте.</p>